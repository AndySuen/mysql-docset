<!--?xml version="1.0" encoding="UTF-8" standalone="no"?--><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><a class="dashingAutolink" name="autolink-3162"></a><a class="dashAnchor" name="//apple_ref/cpp/Package/27.12.4.1%C2%A0The%20events_waits_current%20Table"></a><title>27.12.4.1&nbsp;The events_waits_current Table</title><link rel="stylesheet" type="text/css" href="mvl-otn.css"/><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"/><link rel="home" href="performance-schema" title="MySQL 8.0 Reference Manual"/><link rel="up" href="performance-schema-wait-tables.html" title="27.12.4&nbsp;Performance Schema Wait Event Tables"/><link rel="prev" href="performance-schema-wait-tables.html" title="27.12.4&nbsp;Performance Schema Wait Event Tables"/><link rel="next" href="performance-schema-events-waits-history-table.html" title="27.12.4.2&nbsp;The events_waits_history Table"/><script>window.ohcglobal || document.write('<script src="../../../en/dcommon/js/global.js">\x3C/script>')</script></head><body><div class="skip-link"><a href="performance-schema-events-waits-current-table.html#performance-schema-events-waits-current-table">Skip to Main Content</a></div><div class="DocTitle"><p>MySQL 8.0 Reference Manual Including MySQL NDB Cluster 8.0</p></div><div class="navigation"><ul><li class="navLinkPrevious"><a accesskey="p" title="Go To Previous Page&nbsp;[access key: p]" href="performance-schema-wait-tables.html">Previous <span class="navHint"> Performance Schema Wait Event Tables </span></a></li><li class="navLinkHome"><a accesskey="h" title="Go To Home Page&nbsp;[access key: h]" href="performance-schema">Home <span class="navHint"> MySQL 8.0 Reference Manual Including MySQL NDB Cluster 8.0 </span></a></li><li class="navLinkUp"><a accesskey="u" title="Go Up A Level In The Navigation&nbsp;[access key: u]" href="performance-schema-wait-tables.html">Up <span class="navHint"> Performance Schema Wait Event Tables </span></a></li><li class="navLinkNext"><a accesskey="n" title="Go To Next Page&nbsp;[access key: n]" href="performance-schema-events-waits-history-table.html">Next <span class="navHint"> The events_waits_history Table </span></a></li></ul></div><div class="section"><div class="titlepage"><div><div><a class="dashingAutolink" name="autolink-3163"></a><a class="dashAnchor" name="//apple_ref/cpp/Section/27.12.4.1%C2%A0The%20events_waits_current%20Table"></a><h4 class="title"><a id="performance-schema-events-waits-current-table"></a>27.12.4.1&nbsp;The events_waits_current Table</h4></div></div></div><a id="idm45828790631520" class="indexterm"></a><a id="idm45828790630016" class="indexterm"></a><p>
          The <a class="link" href="performance-schema-events-waits-current-table.html" title="27.12.4.1&nbsp;The events_waits_current Table"><code class="literal">events_waits_current</code></a> table
          contains current wait events. The table stores one row per
          thread showing the current status of the thread&#39;s most recent
          monitored wait event, so there is no system variable for
          configuring the table size.
        </p><p>
          Of the tables that contain wait event rows,
          <a class="link" href="performance-schema-events-waits-current-table.html" title="27.12.4.1&nbsp;The events_waits_current Table"><code class="literal">events_waits_current</code></a> is the most
          fundamental. Other tables that contain wait event rows are
          logically derived from the current events. For example, the
          <a class="link" href="performance-schema-events-waits-history-table.html" title="27.12.4.2&nbsp;The events_waits_history Table"><code class="literal">events_waits_history</code></a> and
          <a class="link" href="performance-schema-events-waits-history-long-table.html" title="27.12.4.3&nbsp;The events_waits_history_long Table"><code class="literal">events_waits_history_long</code></a> tables
          are collections of the most recent wait events that have
          ended, up to a maximum number of rows per thread and globally
          across all threads, respectively.
        </p><p>
          For more information about the relationship between the three
          wait event tables, see
          <a class="xref" href="performance-schema-event-tables.html" title="27.9&nbsp;Performance Schema Tables for Current and Historical Events">Section&nbsp;27.9, &ldquo;Performance Schema Tables for Current and Historical Events&rdquo;</a>.
        </p><p>
          For information about configuring whether to collect wait
          events, see <a class="xref" href="performance-schema-wait-tables.html" title="27.12.4&nbsp;Performance Schema Wait Event Tables">Section&nbsp;27.12.4, &ldquo;Performance Schema Wait Event Tables&rdquo;</a>.
        </p><p>
          The <a class="link" href="performance-schema-events-waits-current-table.html" title="27.12.4.1&nbsp;The events_waits_current Table"><code class="literal">events_waits_current</code></a> table
          has these columns:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">THREAD_ID</code>, <code class="literal">EVENT_ID</code>
            </p><p>
              The thread associated with the event and the thread
              current event number when the event starts. The
              <code class="literal">THREAD_ID</code> and
              <code class="literal">EVENT_ID</code> values taken together uniquely
              identify the row. No two rows have the same pair of
              values.
            </p></li><li class="listitem"><p>
              <code class="literal">END_EVENT_ID</code>
            </p><p>
              This column is set to <code class="literal">NULL</code> when the
              event starts and updated to the thread current event
              number when the event ends.
            </p></li><li class="listitem"><p>
              <code class="literal">EVENT_NAME</code>
            </p><p>
              The name of the instrument that produced the event. This
              is a <code class="literal">NAME</code> value from the
              <a class="link" href="performance-schema-setup-instruments-table.html" title="27.12.2.3&nbsp;The setup_instruments Table"><code class="literal">setup_instruments</code></a> table.
              Instrument names may have multiple parts and form a
              hierarchy, as discussed in
              <a class="xref" href="performance-schema-instrument-naming.html" title="27.6&nbsp;Performance Schema Instrument Naming Conventions">Section&nbsp;27.6, &ldquo;Performance Schema Instrument Naming Conventions&rdquo;</a>.
            </p></li><li class="listitem"><p>
              <code class="literal">SOURCE</code>
            </p><p>
              The name of the source file containing the instrumented
              code that produced the event and the line number in the
              file at which the instrumentation occurs. This enables you
              to check the source to determine exactly what code is
              involved. For example, if a mutex or lock is being
              blocked, you can check the context in which this occurs.
            </p></li><li class="listitem"><p>
              <code class="literal">TIMER_START</code>,
              <code class="literal">TIMER_END</code>,
              <code class="literal">TIMER_WAIT</code>
            </p><p>
              Timing information for the event. The unit for these
              values is picoseconds (trillionths of a second). The
              <code class="literal">TIMER_START</code> and
              <code class="literal">TIMER_END</code> values indicate when event
              timing started and ended. <code class="literal">TIMER_WAIT</code> is
              the event elapsed time (duration).
            </p><p>
              If an event has not finished, <code class="literal">TIMER_END</code>
              is the current timer value and
              <code class="literal">TIMER_WAIT</code> is the time elapsed so far
              (<code class="literal">TIMER_END</code> &minus;
              <code class="literal">TIMER_START</code>).
            </p><p>
              If an event is produced from an instrument that has
              <code class="literal">TIMED = NO</code>, timing information is not
              collected, and <code class="literal">TIMER_START</code>,
              <code class="literal">TIMER_END</code>, and
              <code class="literal">TIMER_WAIT</code> are all
              <code class="literal">NULL</code>.
            </p><p>
              For discussion of picoseconds as the unit for event times
              and factors that affect time values, see
              <a class="xref" href="performance-schema-timing.html" title="27.4.1&nbsp;Performance Schema Event Timing">Section&nbsp;27.4.1, &ldquo;Performance Schema Event Timing&rdquo;</a>.
            </p></li><li class="listitem"><p>
              <code class="literal">SPINS</code>
            </p><p>
              For a mutex, the number of spin rounds. If the value is
              <code class="literal">NULL</code>, the code does not use spin rounds
              or spinning is not instrumented.
            </p></li><li class="listitem"><p>
              <code class="literal">OBJECT_SCHEMA</code>,
              <code class="literal">OBJECT_NAME</code>,
              <code class="literal">OBJECT_TYPE</code>,
              <code class="literal">OBJECT_INSTANCE_BEGIN</code>
            </p><p>
              These columns identify the object <span class="quote">&ldquo;<span class="quote">being acted
              on.</span>&rdquo;</span> What that means depends on the object type.
            </p><p>
              For a synchronization object (<code class="literal">cond</code>,
              <code class="literal">mutex</code>, <code class="literal">rwlock</code>):
            </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                  <code class="literal">OBJECT_SCHEMA</code>,
                  <code class="literal">OBJECT_NAME</code>, and
                  <code class="literal">OBJECT_TYPE</code> are
                  <code class="literal">NULL</code>.
                </p></li><li class="listitem"><p>
                  <code class="literal">OBJECT_INSTANCE_BEGIN</code> is the
                  address of the synchronization object in memory.
                </p></li></ul></div><p>
              For a file I/O object:
            </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                  <code class="literal">OBJECT_SCHEMA</code> is
                  <code class="literal">NULL</code>.
                </p></li><li class="listitem"><p>
                  <code class="literal">OBJECT_NAME</code> is the file name.
                </p></li><li class="listitem"><p>
                  <code class="literal">OBJECT_TYPE</code> is
                  <code class="literal">FILE</code>.
                </p></li><li class="listitem"><p>
                  <code class="literal">OBJECT_INSTANCE_BEGIN</code> is an address
                  in memory.
                </p></li></ul></div><p>
              For a socket object:
            </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                  <code class="literal">OBJECT_NAME</code> is the
                  <code class="literal">IP:PORT</code> value for the socket.
                </p></li><li class="listitem"><p>
                  <code class="literal">OBJECT_INSTANCE_BEGIN</code> is an address
                  in memory.
                </p></li></ul></div><p>
              For a table I/O object:
            </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                  <code class="literal">OBJECT_SCHEMA</code> is the name of the
                  schema that contains the table.
                </p></li><li class="listitem"><p>
                  <code class="literal">OBJECT_NAME</code> is the table name.
                </p></li><li class="listitem"><p>
                  <code class="literal">OBJECT_TYPE</code> is
                  <code class="literal">TABLE</code> for a persistent base table
                  or <code class="literal">TEMPORARY TABLE</code> for a temporary
                  table.
                </p></li><li class="listitem"><p>
                  <code class="literal">OBJECT_INSTANCE_BEGIN</code> is an address
                  in memory.
                </p></li></ul></div><p>
              An <code class="literal">OBJECT_INSTANCE_BEGIN</code> value itself
              has no meaning, except that different values indicate
              different objects.
              <code class="literal">OBJECT_INSTANCE_BEGIN</code> can be used for
              debugging. For example, it can be used with <code class="literal">GROUP
              BY OBJECT_INSTANCE_BEGIN</code> to see whether the load
              on 1,000 mutexes (that protect, say, 1,000 pages or blocks
              of data) is spread evenly or just hitting a few
              bottlenecks. This can help you correlate with other
              sources of information if you see the same object address
              in a log file or another debugging or performance tool.
            </p></li><li class="listitem"><p>
              <code class="literal">INDEX_NAME</code>
            </p><p>
              The name of the index used. <code class="literal">PRIMARY</code>
              indicates the table primary index. <code class="literal">NULL</code>
              means that no index was used.
            </p></li><li class="listitem"><p>
              <code class="literal">NESTING_EVENT_ID</code>
            </p><p>
              The <code class="literal">EVENT_ID</code> value of the event within
              which this event is nested.
            </p></li><li class="listitem"><p>
              <code class="literal">NESTING_EVENT_TYPE</code>
            </p><p>
              The nesting event type. The value is
              <code class="literal">TRANSACTION</code>,
              <code class="literal">STATEMENT</code>, <code class="literal">STAGE</code>, or
              <code class="literal">WAIT</code>.
            </p></li><li class="listitem"><p>
              <code class="literal">OPERATION</code>
            </p><p>
              The type of operation performed, such as
              <code class="literal">lock</code>, <code class="literal">read</code>, or
              <code class="literal">write</code>.
            </p></li><li class="listitem"><p>
              <code class="literal">NUMBER_OF_BYTES</code>
            </p><p>
              The number of bytes read or written by the operation. For
              table I/O waits (events for the
              <code class="literal">wait/io/table/sql/handler</code> instrument),
              <code class="literal">NUMBER_OF_BYTES</code> indicates the number of
              rows. If the value is greater than 1, the event is for a
              batch I/O operation. The following discussion describes
              the difference between exclusively single-row reporting
              and reporting that reflects batch I/O.
            </p><p>
              MySQL executes joins using a nested-loop implementation.
              The job of the Performance Schema instrumentation is to
              provide row count and accumulated execution time per table
              in the join. Assume a join query of the following form
              that is executed using a table join order of
              <code class="literal">t1</code>, <code class="literal">t2</code>,
              <code class="literal">t3</code>:
            </p><pre class="programlisting">SELECT ... FROM t1 JOIN t2 ON ... JOIN t3 ON ...
</pre><p>
              Table <span class="quote">&ldquo;<span class="quote">fanout</span>&rdquo;</span> is the increase or decrease in
              number of rows from adding a table during join processing.
              If the fanout for table <code class="literal">t3</code> is greater
              than 1, the majority of row-fetch operations are for that
              table. Suppose that the join accesses 10 rows from
              <code class="literal">t1</code>, 20 rows from <code class="literal">t2</code>
              per row from <code class="literal">t1</code>, and 30 rows from
              <code class="literal">t3</code> per row of table
              <code class="literal">t2</code>. With single-row reporting, the
              total number of instrumented operations is:
            </p><pre class="programlisting">10 + (10 * 20) + (10 * 20 * 30) = 6210
</pre><p>
              A significant reduction in the number of instrumented
              operations is achievable by aggregating them per scan
              (that is, per unique combination of rows from
              <code class="literal">t1</code> and <code class="literal">t2</code>). With
              batch I/O reporting, the Performance Schema produces an
              event for each scan of the innermost table
              <code class="literal">t3</code> rather than for each row, and the
              number of instrumented row operations reduces to:
            </p><pre class="programlisting">10 + (10 * 20) + (10 * 20) = 410
</pre><p>
              That is a reduction of 93%, illustrating how the
              batch-reporting strategy significantly reduces Performance
              Schema overhead for table I/O by reducing the number of
              reporting calls. The tradeoff is lesser accuracy for event
              timing. Rather than time for an individual row operation
              as in per-row reporting, timing for batch I/O includes
              time spent for operations such as join buffering,
              aggregation, and returning rows to the client.
            </p><p>
              For batch I/O reporting to occur, these conditions must be
              true:
            </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                  Query execution accesses the innermost table of a
                  query block (for a single-table query, that table
                  counts as innermost)
                </p></li><li class="listitem"><p>
                  Query execution does not request a single row from the
                  table (so, for example,
                  <a class="link" href="explain-output.html#jointype_eq_ref"><code class="literal">eq_ref</code></a> access
                  prevents use of batch reporting)
                </p></li><li class="listitem"><p>
                  Query execution does not evaluate a subquery
                  containing table access for the table
                </p></li></ul></div></li><li class="listitem"><p>
              <code class="literal">FLAGS</code>
            </p><p>
              Reserved for future use.
            </p></li></ul></div><p>
          The <a class="link" href="performance-schema-events-waits-current-table.html" title="27.12.4.1&nbsp;The events_waits_current Table"><code class="literal">events_waits_current</code></a> table
          has these indexes:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              Primary key on (<code class="literal">THREAD_ID</code>,
              <code class="literal">EVENT_ID</code>)
            </p></li></ul></div><p>
          <a class="link" href="truncate-table.html" title="13.1.37&nbsp;TRUNCATE TABLE Statement"><code class="literal">TRUNCATE TABLE</code></a> is permitted for
          the <a class="link" href="performance-schema-events-waits-current-table.html" title="27.12.4.1&nbsp;The events_waits_current Table"><code class="literal">events_waits_current</code></a> table.
          It removes the rows.
        </p></div><div class="navigation"><ul><li class="navLinkPrevious"><a title="Go To Previous Page" href="performance-schema-wait-tables.html">Previous <span class="navHint"> Performance Schema Wait Event Tables </span></a></li><li class="navLinkHome"><a title="Go To Home Page" href="performance-schema">Home <span class="navHint"> MySQL 8.0 Reference Manual Including MySQL NDB Cluster 8.0 </span></a></li><li class="navLinkUp"><a title="Go Up A Level In The Navigation" href="performance-schema-wait-tables.html">Up <span class="navHint"> Performance Schema Wait Event Tables </span></a></li><li class="navLinkNext"><a title="Go To Next Page" href="performance-schema-events-waits-history-table.html">Next <span class="navHint"> The events_waits_history Table </span></a></li></ul></div><div class="dochomelink-footer"><a title="Go to MySQL Doc Library" href="https://docs.oracle.com/cd/E17952_01/index.html">
        MySQL Documentation Library
      </a></div><div class="copyright-footer"></div></body></html>