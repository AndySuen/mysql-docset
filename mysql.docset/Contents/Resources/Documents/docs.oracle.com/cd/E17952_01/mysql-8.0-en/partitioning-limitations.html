<!--?xml version="1.0" encoding="UTF-8" standalone="no"?--><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><a class="dashingAutolink" name="autolink-3056"></a><a class="dashAnchor" name="//apple_ref/cpp/Package/24.6%C2%A0Restrictions%20and%20Limitations%20on%20Partitioning"></a><title>24.6&nbsp;Restrictions and Limitations on Partitioning</title><link rel="stylesheet" type="text/css" href="mvl-otn.css"/><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"/><link rel="home" href="performance-schema" title="MySQL 8.0 Reference Manual"/><link rel="up" href="partitioning.html" title="Chapter&nbsp;24&nbsp;Partitioning"/><link rel="prev" href="partitioning-selection.html" title="24.5&nbsp;Partition Selection"/><link rel="next" href="partitioning-limitations-partitioning-keys-unique-keys.html" title="24.6.1&nbsp;Partitioning Keys, Primary Keys, and Unique Keys"/><script>window.ohcglobal || document.write('<script src="../../../en/dcommon/js/global.js">\x3C/script>')</script></head><body><div class="skip-link"><a href="partitioning-limitations.html#partitioning-limitations">Skip to Main Content</a></div><div class="DocTitle"><p>MySQL 8.0 Reference Manual Including MySQL NDB Cluster 8.0</p></div><div class="navigation"><ul><li class="navLinkPrevious"><a accesskey="p" title="Go To Previous Page&nbsp;[access key: p]" href="partitioning-selection.html">Previous <span class="navHint"> Partition Selection </span></a></li><li class="navLinkHome"><a accesskey="h" title="Go To Home Page&nbsp;[access key: h]" href="performance-schema">Home <span class="navHint"> MySQL 8.0 Reference Manual Including MySQL NDB Cluster 8.0 </span></a></li><li class="navLinkUp"><a accesskey="u" title="Go Up A Level In The Navigation&nbsp;[access key: u]" href="partitioning.html">Up <span class="navHint"> Partitioning </span></a></li><li class="navLinkNext"><a accesskey="n" title="Go To Next Page&nbsp;[access key: n]" href="partitioning-limitations-partitioning-keys-unique-keys.html">Next <span class="navHint"> Partitioning Keys, Primary Keys, and Unique Keys </span></a></li></ul></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="partitioning-limitations"></a>24.6&nbsp;Restrictions and Limitations on Partitioning</h2></div></div></div><div class="toc"><ul class="toc"><li><span class="section"><a href="partitioning-limitations-partitioning-keys-unique-keys.html">24.6.1 Partitioning Keys, Primary Keys, and Unique Keys</a></span></li><li><span class="section"><a href="partitioning-limitations-storage-engines.html">24.6.2 Partitioning Limitations Relating to Storage Engines</a></span></li><li><span class="section"><a href="partitioning-limitations-functions.html">24.6.3 Partitioning Limitations Relating to Functions</a></span></li></ul></div><a id="idm45828800799360" class="indexterm"></a><p>
      This section discusses current restrictions and limitations on
      MySQL partitioning support.
    </p><p><strong>Prohibited constructs.&nbsp;</strong>
        The following constructs are not permitted in partitioning
        expressions:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          Stored procedures, stored functions, loadable functions, or
          plugins.
        </p></li><li class="listitem"><p>
          Declared variables or user variables.
        </p></li></ul></div><p>
      For a list of SQL functions which are permitted in partitioning
      expressions, see
      <a class="xref" href="partitioning-limitations-functions.html" title="24.6.3&nbsp;Partitioning Limitations Relating to Functions">Section&nbsp;24.6.3, &ldquo;Partitioning Limitations Relating to Functions&rdquo;</a>.
    </p><p><strong>Arithmetic and logical operators.&nbsp;</strong>
        <a id="idm45828800791856" class="indexterm"></a>

        <a id="idm45828800790336" class="indexterm"></a>

        Use of the arithmetic operators
        <a class="link" href="arithmetic-functions.html#operator_plus"><code class="literal">+</code></a>,
        <a class="link" href="arithmetic-functions.html#operator_minus"><code class="literal">-</code></a>, and
        <a class="link" href="arithmetic-functions.html#operator_times"><code class="literal">*</code></a> is permitted in
        partitioning expressions. However, the result must be an integer
        value or <code class="literal">NULL</code> (except in the case of
        <code class="literal">[LINEAR] KEY</code> partitioning, as discussed
        elsewhere in this chapter; see
        <a class="xref" href="partitioning-types.html" title="24.2&nbsp;Partitioning Types">Section&nbsp;24.2, &ldquo;Partitioning Types&rdquo;</a>, for more information).
      </p><p>
      The <a class="link" href="arithmetic-functions.html#operator_div"><code class="literal">DIV</code></a> operator is also supported;
      the <a class="link" href="arithmetic-functions.html#operator_divide"><code class="literal">/</code></a> operator is
      not permitted.
    </p><p>
      The bit operators
      <a class="link" href="bit-functions.html#operator_bitwise-or"><code class="literal">|</code></a>,
      <a class="link" href="bit-functions.html#operator_bitwise-and"><code class="literal">&amp;</code></a>,
      <a class="link" href="bit-functions.html#operator_bitwise-xor"><code class="literal">^</code></a>,
      <a class="link" href="bit-functions.html#operator_left-shift"><code class="literal">&lt;&lt;</code></a>,
      <a class="link" href="bit-functions.html#operator_right-shift"><code class="literal">&gt;&gt;</code></a>, and
      <a class="link" href="bit-functions.html#operator_bitwise-invert"><code class="literal">~</code></a> are not
      permitted in partitioning expressions.
    </p><p><strong>Server SQL mode.&nbsp;</strong>
        <a id="idm45828800771040" class="indexterm"></a>

        <a id="idm45828800769552" class="indexterm"></a>

        Tables employing user-defined partitioning do not preserve the
        SQL mode in effect at the time that they were created. As
        discussed elsewhere in this Manual (see
        <a class="xref" href="sql-mode.html" title="5.1.11&nbsp;Server SQL Modes">Section&nbsp;5.1.11, &ldquo;Server SQL Modes&rdquo;</a>), the results of many MySQL functions
        and operators may change according to the server SQL mode.
        Therefore, a change in the SQL mode at any time after the
        creation of partitioned tables may lead to major changes in the
        behavior of such tables, and could easily lead to corruption or
        loss of data. For these reasons, <span class="emphasis"><em>it is strongly
        recommended that you never change the server SQL mode after
        creating partitioned tables</em></span>.
      </p><p>
      For one such change in the server SQL mode making a partitioned
      tables unusable, consider the following
      <a class="link" href="create-table.html" title="13.1.20&nbsp;CREATE TABLE Statement"><code class="literal">CREATE TABLE</code></a> statement, which can
      be executed successfully only if the
      <a class="link" href="sql-mode.html#sqlmode_no_unsigned_subtraction"><code class="literal">NO_UNSIGNED_SUBTRACTION</code></a> mode is
      in effect:
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT @@sql_mode;</code></strong>
+------------+
| @@sql_mode |
+------------+
|            |
+------------+
1 row in set (0.00 sec)

mysql&gt; <strong class="userinput"><code>CREATE TABLE tu (c1 BIGINT UNSIGNED)</code></strong>
    -&gt;   <strong class="userinput"><code>PARTITION BY RANGE(c1 - 10) (</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION p0 VALUES LESS THAN (-5),</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION p1 VALUES LESS THAN (0),</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION p2 VALUES LESS THAN (5),</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION p3 VALUES LESS THAN (10),</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION p4 VALUES LESS THAN (MAXVALUE)</code></strong>
    -&gt; <strong class="userinput"><code>);</code></strong>
<span class="errortext">ERROR 1563 (HY000): Partition constant is out of partition function domain</span>

mysql&gt; <strong class="userinput"><code>SET sql_mode=&#39;NO_UNSIGNED_SUBTRACTION&#39;;</code></strong>
Query OK, 0 rows affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>SELECT @@sql_mode;</code></strong>
+-------------------------+
| @@sql_mode              |
+-------------------------+
| NO_UNSIGNED_SUBTRACTION |
+-------------------------+
1 row in set (0.00 sec)

mysql&gt; <strong class="userinput"><code>CREATE TABLE tu (c1 BIGINT UNSIGNED)</code></strong>
    -&gt;   <strong class="userinput"><code>PARTITION BY RANGE(c1 - 10) (</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION p0 VALUES LESS THAN (-5),</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION p1 VALUES LESS THAN (0),</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION p2 VALUES LESS THAN (5),</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION p3 VALUES LESS THAN (10),</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION p4 VALUES LESS THAN (MAXVALUE)</code></strong>
    -&gt; <strong class="userinput"><code>);</code></strong>
Query OK, 0 rows affected (0.05 sec)
</pre><p>
      If you remove the
      <a class="link" href="sql-mode.html#sqlmode_no_unsigned_subtraction"><code class="literal">NO_UNSIGNED_SUBTRACTION</code></a> server
      SQL mode after creating <code class="literal">tu</code>, you may no longer
      be able to access this table:
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SET sql_mode=&#39;&#39;;</code></strong>
Query OK, 0 rows affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>SELECT * FROM tu;</code></strong>
<span class="errortext">ERROR 1563 (HY000): Partition constant is out of partition function domain</span>
mysql&gt; <strong class="userinput"><code>INSERT INTO tu VALUES (20);</code></strong>
<span class="errortext">ERROR 1563 (HY000): Partition constant is out of partition function domain</span>
</pre><p>
      See also <a class="xref" href="sql-mode.html" title="5.1.11&nbsp;Server SQL Modes">Section&nbsp;5.1.11, &ldquo;Server SQL Modes&rdquo;</a>.
    </p><p>
      Server SQL modes also impact replication of partitioned tables.
      Disparate SQL modes on source and replica can lead to partitioning
      expressions being evaluated differently; this can cause the
      distribution of data among partitions to be different in the
      source&#39;s and replica&#39;s copies of a given table, and may
      even cause inserts into partitioned tables that succeed on the
      source to fail on the replica. For best results, you should always
      use the same server SQL mode on the source and on the replica.
    </p><p><strong>Performance considerations.&nbsp;</strong>
        Some effects of partitioning operations on performance are given
        in the following list:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a id="partitioning-limitations-file-system-ops"></a><a class="dashingAutolink" name="autolink-3052"></a><a class="dashAnchor" name="//apple_ref/cpp/Notation/File%20system%20operations."></a><strong>File system operations.&nbsp;</strong>
            Partitioning and repartitioning operations (such as
            <a class="link" href="alter-table-partition-operations.html" title="13.1.9.1&nbsp;ALTER TABLE Partition Operations"><code class="literal">ALTER
            TABLE</code></a> with <code class="literal">PARTITION BY ...</code>,
            <code class="literal">REORGANIZE PARTITION</code>, or <code class="literal">REMOVE
            PARTITIONING</code>) depend on file system operations for
            their implementation. This means that the speed of these
            operations is affected by such factors as file system type
            and characteristics, disk speed, swap space, file handling
            efficiency of the operating system, and MySQL server options
            and variables that relate to file handling. In particular,
            you should make sure that
            <a class="link" href="server-system-variables.html#sysvar_large_files_support"><code class="literal">large_files_support</code></a> is
            enabled and that
            <a class="link" href="server-system-variables.html#sysvar_open_files_limit"><code class="literal">open_files_limit</code></a> is set
            properly. Partitioning and repartitioning operations
            involving <code class="literal">InnoDB</code> tables may be made more
            efficient by enabling
            <a class="link" href="innodb-parameters.html#sysvar_innodb_file_per_table"><code class="literal">innodb_file_per_table</code></a>.
          </p><p>
          See also
          <a class="xref" href="partitioning-limitations.html#partitioning-limitations-max-partitions" title="Maximum number of partitions">Maximum number of partitions</a>.
        </p></li><li class="listitem"><p><a class="dashingAutolink" name="autolink-3053"></a><a class="dashAnchor" name="//apple_ref/cpp/Notation/Table%20locks."></a><strong>Table locks.&nbsp;</strong>
            Generally, the process executing a partitioning operation on
            a table takes a write lock on the table. Reads from such
            tables are relatively unaffected; pending
            <a class="link" href="insert.html" title="13.2.7&nbsp;INSERT Statement"><code class="literal">INSERT</code></a> and
            <a class="link" href="update.html" title="13.2.17&nbsp;UPDATE Statement"><code class="literal">UPDATE</code></a> operations are
            performed as soon as the partitioning operation has
            completed. For <code class="literal">InnoDB</code>-specific exceptions
            to this limitation, see
            <a class="xref" href="innodb-online-ddl-operations.html#online-ddl-partitioning" title="Partitioning Operations">Partitioning Operations</a>.
          </p></li><li class="listitem"><p><a class="dashingAutolink" name="autolink-3054"></a><a class="dashAnchor" name="//apple_ref/cpp/Notation/Indexes%3B%20partition%20pruning."></a><strong>Indexes; partition pruning.&nbsp;</strong>
            As with nonpartitioned tables, proper use of indexes can
            speed up queries on partitioned tables significantly. In
            addition, designing partitioned tables and queries on these
            tables to take advantage of
            <span class="firstterm">partition pruning</span> can
            improve performance dramatically. See
            <a class="xref" href="partitioning-pruning.html" title="24.4&nbsp;Partition Pruning">Section&nbsp;24.4, &ldquo;Partition Pruning&rdquo;</a>, for more
            information.
          </p><p>
          Index condition pushdown is supported for partitioned tables.
          See <a class="xref" href="index-condition-pushdown-optimization.html" title="8.2.1.6&nbsp;Index Condition Pushdown Optimization">Section&nbsp;8.2.1.6, &ldquo;Index Condition Pushdown Optimization&rdquo;</a>.
        </p></li><li class="listitem"><p><a class="dashingAutolink" name="autolink-3055"></a><a class="dashAnchor" name="//apple_ref/cpp/Notation/Performance%20with%20LOAD%20DATA."></a><strong>Performance with LOAD DATA.&nbsp;</strong>
            In MySQL 8.0, <a class="link" href="load-data.html" title="13.2.9&nbsp;LOAD DATA Statement"><code class="literal">LOAD
            DATA</code></a> uses buffering to improve performance. You
            should be aware that the buffer uses 130 KB memory per
            partition to achieve this.
          </p></li></ul></div><p><a id="partitioning-limitations-max-partitions"></a><strong>Maximum number of partitions.&nbsp;</strong><a id="idm45828800710304" class="indexterm"></a><a id="idm45828800708800" class="indexterm"></a>
        The maximum possible number of partitions for a given table not
        using the <a class="link" href="mysql-cluster.html" title="Chapter&nbsp;23&nbsp;MySQL NDB Cluster 8.0"><code class="literal">NDB</code></a> storage engine is
        8192. This number includes subpartitions.
      </p><p>
      The maximum possible number of user-defined partitions for a table
      using the <a class="link" href="mysql-cluster.html" title="Chapter&nbsp;23&nbsp;MySQL NDB Cluster 8.0"><code class="literal">NDB</code></a> storage engine is
      determined according to the version of the NDB Cluster software
      being used, the number of data nodes, and other factors. See
      <a class="xref" href="mysql-cluster-nodes-groups.html#mysql-cluster-nodes-groups-user-partitioning" title="NDB and user-defined partitioning">NDB and user-defined partitioning</a>,
      for more information.
    </p><p>
      If, when creating tables with a large number of partitions (but
      less than the maximum), you encounter an error message such as
      <span class="errortext">Got error ... from storage engine: Out of resources
      when opening file</span>, you may be able to address the
      issue by increasing the value of the
      <a class="link" href="server-system-variables.html#sysvar_open_files_limit"><code class="literal">open_files_limit</code></a> system variable.
      However, this is dependent on the operating system, and may not be
      possible or advisable on all platforms; see
      <a class="xref" href="not-enough-file-handles.html" title="B.3.2.16&nbsp;File Not Found and Similar Errors">Section&nbsp;B.3.2.16, &ldquo;File Not Found and Similar Errors&rdquo;</a>, for more information.
      In some cases, using large numbers (hundreds) of partitions may
      also not be advisable due to other concerns, so using more
      partitions does not automatically lead to better results.
    </p><p>
      See also
      <a class="xref" href="partitioning-limitations.html#partitioning-limitations-file-system-ops" title="File system operations">File system operations</a>.
    </p><p><strong>Foreign keys not supported for partitioned InnoDB tables.&nbsp;</strong><a id="idm45828800697344" class="indexterm"></a>
        Partitioned tables using the <a class="link" href="innodb-storage-engine.html" title="Chapter&nbsp;15&nbsp;The InnoDB Storage Engine"><code class="literal">InnoDB</code></a>
        storage engine do not support foreign keys. More specifically,
        this means that the following two statements are true:
      </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
          No definition of an <code class="literal">InnoDB</code> table employing
          user-defined partitioning may contain foreign key references;
          no <code class="literal">InnoDB</code> table whose definition contains
          foreign key references may be partitioned.
        </p></li><li class="listitem"><p>
          No <code class="literal">InnoDB</code> table definition may contain a
          foreign key reference to a user-partitioned table; no
          <code class="literal">InnoDB</code> table with user-defined partitioning
          may contain columns referenced by foreign keys.
        </p></li></ol></div><p>
      The scope of the restrictions just listed includes all tables that
      use the <code class="literal">InnoDB</code> storage engine.
      <a class="link" href="create-table-foreign-keys.html" title="13.1.20.5&nbsp;FOREIGN KEY Constraints"><code class="literal">CREATE
      TABLE</code></a> and <a class="link" href="alter-table.html" title="13.1.9&nbsp;ALTER TABLE Statement"><code class="literal">ALTER TABLE</code></a>
      statements that would result in tables violating these
      restrictions are not allowed.
    </p><p><strong>ALTER TABLE ... ORDER BY.&nbsp;</strong>
        An <code class="literal">ALTER TABLE ... ORDER BY
        <em class="replaceable"><code>column</code></em></code> statement run
        against a partitioned table causes ordering of rows only within
        each partition.
      </p><p><strong>ADD COLUMN ... ALGORITHM=INSTANT.&nbsp;</strong>
        Once you perform
        <a class="link" href="alter-table.html" title="13.1.9&nbsp;ALTER TABLE Statement"><code class="literal">ALTER TABLE ... ADD
        COLUMN ... ALGORITHM=INSTANT</code></a> on a partitioned table,
        it is no longer possible to exchange partitions with this table.
      </p><p><strong>Effects on REPLACE statements by modification of primary keys.&nbsp;</strong>
        It can be desirable in some cases (see
        <a class="xref" href="partitioning-limitations-partitioning-keys-unique-keys.html" title="24.6.1&nbsp;Partitioning Keys, Primary Keys, and Unique Keys">Section&nbsp;24.6.1, &ldquo;Partitioning Keys, Primary Keys, and Unique Keys&rdquo;</a>)
        to modify a table&#39;s primary key. Be aware that, if your
        application uses <a class="link" href="replace.html" title="13.2.12&nbsp;REPLACE Statement"><code class="literal">REPLACE</code></a>
        statements and you do this, the results of these statements can
        be drastically altered. See <a class="xref" href="replace.html" title="13.2.12&nbsp;REPLACE Statement">Section&nbsp;13.2.12, &ldquo;REPLACE Statement&rdquo;</a>, for more
        information and an example.
      </p><p><strong>FULLTEXT indexes.&nbsp;</strong><a id="idm45828800674624" class="indexterm"></a>
        Partitioned tables do not support <code class="literal">FULLTEXT</code>
        indexes or searches.
      </p><p><strong>Spatial columns.&nbsp;</strong>
        Columns with spatial data types such as <code class="literal">POINT</code>
        or <code class="literal">GEOMETRY</code> cannot be used in partitioned
        tables.
      </p><p><strong>Temporary tables.&nbsp;</strong><a id="idm45828800668432" class="indexterm"></a>
        Temporary tables cannot be partitioned.
      </p><p><strong>Log tables.&nbsp;</strong>
        It is not possible to partition the log tables; an
        <a class="link" href="alter-table-partition-operations.html" title="13.1.9.1&nbsp;ALTER TABLE Partition Operations"><code class="literal">ALTER
        TABLE ... PARTITION BY ...</code></a> statement on such a table
        fails with an error.
      </p><p><strong>Data type of partitioning key.&nbsp;</strong><a id="idm45828800663072" class="indexterm"></a>
        A partitioning key must be either an integer column or an
        expression that resolves to an integer. Expressions employing
        <a class="link" href="enum.html" title="11.3.5&nbsp;The ENUM Type"><code class="literal">ENUM</code></a> columns cannot be used. The
        column or expression value may also be <code class="literal">NULL</code>;
        see <a class="xref" href="partitioning-handling-nulls.html" title="24.2.7&nbsp;How MySQL Partitioning Handles NULL">Section&nbsp;24.2.7, &ldquo;How MySQL Partitioning Handles NULL&rdquo;</a>.
      </p><p>
      There are two exceptions to this restriction:
    </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
          When partitioning by [<code class="literal">LINEAR</code>]
          <code class="literal">KEY</code>, it is possible to use columns of any
          valid MySQL data type other than
          <a class="link" href="blob.html" title="11.3.4&nbsp;The BLOB and TEXT Types"><code class="literal">TEXT</code></a> or
          <a class="link" href="blob.html" title="11.3.4&nbsp;The BLOB and TEXT Types"><code class="literal">BLOB</code></a> as partitioning keys,
          because the internal key-hashing functions produce the correct
          data type from these types. For example, the following two
          <a class="link" href="create-table.html" title="13.1.20&nbsp;CREATE TABLE Statement"><code class="literal">CREATE TABLE</code></a> statements are
          valid:
        </p><pre class="programlisting">CREATE TABLE tkc (c1 CHAR)
PARTITION BY KEY(c1)
PARTITIONS 4;

CREATE TABLE tke
    ( c1 ENUM(&#39;red&#39;, &#39;orange&#39;, &#39;yellow&#39;, &#39;green&#39;, &#39;blue&#39;, &#39;indigo&#39;, &#39;violet&#39;) )
PARTITION BY LINEAR KEY(c1)
PARTITIONS 6;
</pre></li><li class="listitem"><p>
          When partitioning by <code class="literal">RANGE COLUMNS</code> or
          <code class="literal">LIST COLUMNS</code>, it is possible to use string,
          <a class="link" href="datetime.html" title="11.2.2&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">DATE</code></a>, and
          <a class="link" href="datetime.html" title="11.2.2&nbsp;The DATE, DATETIME, and TIMESTAMP Types"><code class="literal">DATETIME</code></a> columns. For example,
          each of the following <a class="link" href="create-table.html" title="13.1.20&nbsp;CREATE TABLE Statement"><code class="literal">CREATE
          TABLE</code></a> statements is valid:
        </p><pre class="programlisting">CREATE TABLE rc (c1 INT, c2 DATE)
PARTITION BY RANGE COLUMNS(c2) (
    PARTITION p0 VALUES LESS THAN(&#39;1990-01-01&#39;),
    PARTITION p1 VALUES LESS THAN(&#39;1995-01-01&#39;),
    PARTITION p2 VALUES LESS THAN(&#39;2000-01-01&#39;),
    PARTITION p3 VALUES LESS THAN(&#39;2005-01-01&#39;),
    PARTITION p4 VALUES LESS THAN(MAXVALUE)
);

CREATE TABLE lc (c1 INT, c2 CHAR(1))
PARTITION BY LIST COLUMNS(c2) (
    PARTITION p0 VALUES IN(&#39;a&#39;, &#39;d&#39;, &#39;g&#39;, &#39;j&#39;, &#39;m&#39;, &#39;p&#39;, &#39;s&#39;, &#39;v&#39;, &#39;y&#39;),
    PARTITION p1 VALUES IN(&#39;b&#39;, &#39;e&#39;, &#39;h&#39;, &#39;k&#39;, &#39;n&#39;, &#39;q&#39;, &#39;t&#39;, &#39;w&#39;, &#39;z&#39;),
    PARTITION p2 VALUES IN(&#39;c&#39;, &#39;f&#39;, &#39;i&#39;, &#39;l&#39;, &#39;o&#39;, &#39;r&#39;, &#39;u&#39;, &#39;x&#39;, NULL)
);
</pre></li></ol></div><p>
      Neither of the preceding exceptions applies to
      <a class="link" href="blob.html" title="11.3.4&nbsp;The BLOB and TEXT Types"><code class="literal">BLOB</code></a> or
      <a class="link" href="blob.html" title="11.3.4&nbsp;The BLOB and TEXT Types"><code class="literal">TEXT</code></a> column types.
    </p><p><strong>Subqueries.&nbsp;</strong><a id="idm45828800638320" class="indexterm"></a>
        A partitioning key may not be a subquery, even if that subquery
        resolves to an integer value or <code class="literal">NULL</code>.
      </p><a id="idm45828800635472" class="indexterm"></a><a id="idm45828800633984" class="indexterm"></a><p><a id="partitioning-limitations-prefixes"></a><strong>Column index prefixes not supported for key partitioning.&nbsp;</strong>
        When creating a table that is partitioned by key, any columns in
        the partitioning key which use column prefixes are not used in
        the table&#39;s partitioning function. Consider the following
        <a class="link" href="create-table.html" title="13.1.20&nbsp;CREATE TABLE Statement"><code class="literal">CREATE TABLE</code></a> statement, which has
        three <a class="link" href="char.html" title="11.3.2&nbsp;The CHAR and VARCHAR Types"><code class="literal">VARCHAR</code></a> columns, and whose
        primary key uses all three columns and specifies prefixes for
        two of them:
      </p><pre class="programlisting">CREATE TABLE t1 (
    a VARCHAR(10000),
    b VARCHAR(25),
    c VARCHAR(10),
    PRIMARY KEY (a(10), b, c(2))
) PARTITION BY KEY() PARTITIONS 2;
</pre><p>
      This statement is accepted, but the resulting table is actually
      created as if you had issued the following statement, using only
      the primary key column which does not include a prefix (column
      <code class="literal">b</code>) for the partitioning key:
    </p><pre class="programlisting">CREATE TABLE t1 (
    a VARCHAR(10000),
    b VARCHAR(25),
    c VARCHAR(10),
    PRIMARY KEY (a(10), b, c(2))
) PARTITION BY KEY(b) PARTITIONS 2;
</pre><p>
      Prior to MySQL 8.0.21, no warning was issued or any other
      indication provided that this occurred, except in the event that
      all columns specified for the partitioning key used prefixes, in
      which case the statement failed, but with a misleading error
      message, as shown here:
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE t2 (</code></strong>
    -&gt;     <strong class="userinput"><code>a VARCHAR(10000),</code></strong>
    -&gt;     <strong class="userinput"><code>b VARCHAR(25),</code></strong>
    -&gt;     <strong class="userinput"><code>c VARCHAR(10),</code></strong>
    -&gt;     <strong class="userinput"><code>PRIMARY KEY (a(10), b(5), c(2))</code></strong>
    -&gt; <strong class="userinput"><code>) PARTITION BY KEY() PARTITIONS 2;</code></strong>
<span class="errortext">ERROR 1503 (HY000): A PRIMARY KEY must include all columns in the
table&#39;s partitioning function</span>
</pre><p>
      This also occurred when performing <a class="link" href="alter-table.html" title="13.1.9&nbsp;ALTER TABLE Statement"><code class="literal">ALTER
      TABLE</code></a> or when upgrading such tables.
    </p><p>
      This permissive behavior is deprecated as of MySQL 8.0.21 (and is
      subject to removal in a future version of MySQL). Beginning with
      MySQL 8.0.21, using one or more columns having a prefix in the
      partitioning key results in a warning for each such column, as
      shown here:
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE t1 (</code></strong>
    -&gt;     <strong class="userinput"><code>a VARCHAR(10000),</code></strong>
    -&gt;     <strong class="userinput"><code>b VARCHAR(25),</code></strong>
    -&gt;     <strong class="userinput"><code>c VARCHAR(10),</code></strong>
    -&gt;     <strong class="userinput"><code>PRIMARY KEY (a(10), b, c(2))</code></strong>
    -&gt; <strong class="userinput"><code>) PARTITION BY KEY() PARTITIONS 2;</code></strong>
Query OK, 0 rows affected, 2 warnings (1.25 sec)

mysql&gt; <strong class="userinput"><code>SHOW WARNINGS\G</code></strong>
*************************** 1. row ***************************
  Level: Warning
   Code: 1681
Message: Column &#39;test.t1.a&#39; having prefix key part &#39;a(10)&#39; is ignored by the
partitioning function. Use of prefixed columns in the PARTITION BY KEY() clause
is deprecated and will be removed in a future release.
*************************** 2. row ***************************
  Level: Warning
   Code: 1681
Message: Column &#39;test.t1.c&#39; having prefix key part &#39;c(2)&#39; is ignored by the
partitioning function. Use of prefixed columns in the PARTITION BY KEY() clause
is deprecated and will be removed in a future release.
2 rows in set (0.00 sec)
</pre><p>
      This includes cases in which the columns used in the partitioning
      function are defined implicitly as those in the table&#39;s
      primary key by employing an empty <code class="literal">PARTITION BY
      KEY()</code> clause.
    </p><p>
      In MySQL 8.0.21 and later, if all columns specified for the
      partitioning key employ prefixes, the <code class="literal">CREATE
      TABLE</code> statement used fails with an error message that
      identifies the issue correctly:
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE t1 (</code></strong>
    -&gt;     <strong class="userinput"><code>a VARCHAR(10000),</code></strong>
    -&gt;     <strong class="userinput"><code>b VARCHAR(25),</code></strong>
    -&gt;     <strong class="userinput"><code>c VARCHAR(10),</code></strong>
    -&gt;     <strong class="userinput"><code>PRIMARY KEY (a(10), b(5), c(2))</code></strong>
    -&gt; <strong class="userinput"><code>) PARTITION BY KEY() PARTITIONS 2;</code></strong>
<span class="errortext">ERROR 1503 (HY000): A PRIMARY KEY must include all columns in the table&#39;s
partitioning function (prefixed columns are not considered).</span>
</pre><p>
      For general information about partitioning tables by key, see
      <a class="xref" href="partitioning-key.html" title="24.2.5&nbsp;KEY Partitioning">Section&nbsp;24.2.5, &ldquo;KEY Partitioning&rdquo;</a>.
    </p><p><a id="partitioning-limitations-subpartitions"></a><strong>Issues with subpartitions.&nbsp;</strong><a id="idm45828800598336" class="indexterm"></a><a id="idm45828800596848" class="indexterm"></a>
        Subpartitions must use <code class="literal">HASH</code> or
        <code class="literal">KEY</code> partitioning. Only
        <code class="literal">RANGE</code> and <code class="literal">LIST</code> partitions
        may be subpartitioned; <code class="literal">HASH</code> and
        <code class="literal">KEY</code> partitions cannot be subpartitioned.
      </p><p>
      <a id="idm45828800590208" class="indexterm"></a>

      <code class="literal">SUBPARTITION BY KEY</code> requires that the
      subpartitioning column or columns be specified explicitly, unlike
      the case with <code class="literal">PARTITION BY KEY</code>, where it can be
      omitted (in which case the table&#39;s primary key column is used
      by default). Consider the table created by this statement:
    </p><pre class="programlisting">CREATE TABLE ts (
    id INT NOT NULL AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(30)
);
</pre><p>
      You can create a table having the same columns, partitioned by
      <code class="literal">KEY</code>, using a statement such as this one:
    </p><pre class="programlisting">CREATE TABLE ts (
    id INT NOT NULL AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(30)
)
PARTITION BY KEY()
PARTITIONS 4;
</pre><p>
      The previous statement is treated as though it had been written
      like this, with the table&#39;s primary key column used as the
      partitioning column:
    </p><pre class="programlisting">CREATE TABLE ts (
    id INT NOT NULL AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(30)
)
PARTITION BY KEY(id)
PARTITIONS 4;
        </pre><p>
      However, the following statement that attempts to create a
      subpartitioned table using the default column as the
      subpartitioning column fails, and the column must be specified for
      the statement to succeed, as shown here:
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CREATE TABLE ts (</code></strong>
    -&gt;     <strong class="userinput"><code>id INT NOT NULL AUTO_INCREMENT PRIMARY KEY,</code></strong>
    -&gt;     <strong class="userinput"><code>name VARCHAR(30)</code></strong>
    -&gt; <strong class="userinput"><code>)</code></strong>
    -&gt; <strong class="userinput"><code>PARTITION BY RANGE(id)</code></strong>
    -&gt; <strong class="userinput"><code>SUBPARTITION BY KEY()</code></strong>
    -&gt; <strong class="userinput"><code>SUBPARTITIONS 4</code></strong>
    -&gt; <strong class="userinput"><code>(</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION p0 VALUES LESS THAN (100),</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION p1 VALUES LESS THAN (MAXVALUE)</code></strong>
    -&gt; <strong class="userinput"><code>);</code></strong>
<span class="errortext">ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that
corresponds to your MySQL server version for the right syntax to use near &#39;)</span>

mysql&gt; <strong class="userinput"><code>CREATE TABLE ts (</code></strong>
    -&gt;     <strong class="userinput"><code>id INT NOT NULL AUTO_INCREMENT PRIMARY KEY,</code></strong>
    -&gt;     <strong class="userinput"><code>name VARCHAR(30)</code></strong>
    -&gt; <strong class="userinput"><code>)</code></strong>
    -&gt; <strong class="userinput"><code>PARTITION BY RANGE(id)</code></strong>
    -&gt; <strong class="userinput"><code>SUBPARTITION BY KEY(id)</code></strong>
    -&gt; <strong class="userinput"><code>SUBPARTITIONS 4</code></strong>
    -&gt; <strong class="userinput"><code>(</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION p0 VALUES LESS THAN (100),</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION p1 VALUES LESS THAN (MAXVALUE)</code></strong>
    -&gt; <strong class="userinput"><code>);</code></strong>
Query OK, 0 rows affected (0.07 sec)
</pre><p>
      This is a known issue (see Bug #51470).
    </p><p><strong>DATA DIRECTORY and INDEX DIRECTORY options.&nbsp;</strong>
        Table-level <code class="literal">DATA DIRECTORY</code> and <code class="literal">INDEX
        DIRECTORY</code> options are ignored (see Bug #32091). You
        can employ these options for individual partitions or
        subpartitions of <a class="link" href="innodb-storage-engine.html" title="Chapter&nbsp;15&nbsp;The InnoDB Storage Engine"><code class="literal">InnoDB</code></a> tables. As
        of MySQL 8.0.21, the directory specified in a <code class="literal">DATA
        DIRECTORY</code> clause must be known to
        <code class="literal">InnoDB</code>. For more information, see
        <a class="xref" href="innodb-create-table-external.html#innodb-create-table-external-data-directory" title="Using the DATA DIRECTORY Clause">Using the DATA DIRECTORY Clause</a>.
      </p><p><strong>Repairing and rebuilding partitioned tables.&nbsp;</strong>
        The statements <a class="link" href="check-table.html" title="13.7.3.2&nbsp;CHECK TABLE Statement"><code class="literal">CHECK TABLE</code></a>,
        <a class="link" href="optimize-table.html" title="13.7.3.4&nbsp;OPTIMIZE TABLE Statement"><code class="literal">OPTIMIZE TABLE</code></a>,
        <a class="link" href="analyze-table.html" title="13.7.3.1&nbsp;ANALYZE TABLE Statement"><code class="literal">ANALYZE TABLE</code></a>, and
        <a class="link" href="repair-table.html" title="13.7.3.5&nbsp;REPAIR TABLE Statement"><code class="literal">REPAIR TABLE</code></a> are supported for
        partitioned tables.
      </p><p>
      In addition, you can use <code class="literal">ALTER TABLE ... REBUILD
      PARTITION</code> to rebuild one or more partitions of a
      partitioned table; <code class="literal">ALTER TABLE ... REORGANIZE
      PARTITION</code> also causes partitions to be rebuilt. See
      <a class="xref" href="alter-table.html" title="13.1.9&nbsp;ALTER TABLE Statement">Section&nbsp;13.1.9, &ldquo;ALTER TABLE Statement&rdquo;</a>, for more information about these
      two statements.
    </p><p>
      <code class="literal">ANALYZE</code>, <code class="literal">CHECK</code>,
      <code class="literal">OPTIMIZE</code>, <code class="literal">REPAIR</code>, and
      <code class="literal">TRUNCATE</code> operations are supported with
      subpartitions. See
      <a class="xref" href="alter-table-partition-operations.html" title="13.1.9.1&nbsp;ALTER TABLE Partition Operations">Section&nbsp;13.1.9.1, &ldquo;ALTER TABLE Partition Operations&rdquo;</a>.
    </p><p><strong>File name delimiters for partitions and subpartitions.&nbsp;</strong>
        Table partition and subpartition file names include generated
        delimiters such as <code class="literal">#P#</code> and
        <code class="literal">#SP#</code>. The lettercase of such delimiters can
        vary and should not be depended upon.
      </p></div><div class="navigation"><ul><li class="navLinkPrevious"><a title="Go To Previous Page" href="partitioning-selection.html">Previous <span class="navHint"> Partition Selection </span></a></li><li class="navLinkHome"><a title="Go To Home Page" href="performance-schema">Home <span class="navHint"> MySQL 8.0 Reference Manual Including MySQL NDB Cluster 8.0 </span></a></li><li class="navLinkUp"><a title="Go Up A Level In The Navigation" href="partitioning.html">Up <span class="navHint"> Partitioning </span></a></li><li class="navLinkNext"><a title="Go To Next Page" href="partitioning-limitations-partitioning-keys-unique-keys.html">Next <span class="navHint"> Partitioning Keys, Primary Keys, and Unique Keys </span></a></li></ul></div><div class="dochomelink-footer"><a title="Go to MySQL Doc Library" href="https://docs.oracle.com/cd/E17952_01/index.html">
        MySQL Documentation Library
      </a></div><div class="copyright-footer"></div></body></html>